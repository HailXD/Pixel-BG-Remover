<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Pixel Art Background Remover - Click & Remove</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-size: 0.95em;
        }

        .upload-area {
            border: 3px dashed #764ba2;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }

        .upload-area:hover {
            background: #efe9ff;
            border-color: #667eea;
        }

        .upload-area.dragover {
            background: #e0d5ff;
            border-color: #667eea;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        input[type="file"] {
            display: none;
        }

        .workspace {
            display: none;
        }

        .workspace.active {
            display: block;
        }

        .toolbar {
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .toolbar-row {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 15px;
        }

        .toolbar-row:last-child {
            margin-bottom: 0;
        }

        .tool-group {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
            background: white;
            padding: 12px 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .tool-label {
            font-weight: 600;
            color: #555;
            min-width: 100px;
            font-size: 0.9em;
        }

        .slider-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 22px;
            height: 22px;
            background: #764ba2;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 22px;
            height: 22px;
            background: #764ba2;
            cursor: pointer;
            border-radius: 50%;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider-value {
            background: #764ba2;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            min-width: 55px;
            text-align: center;
            font-weight: bold;
            font-size: 0.85em;
        }

        .canvas-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-wrapper {
            position: relative;
            background-image: 
                linear-gradient(45deg, #e0e0e0 25%, transparent 25%),
                linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #e0e0e0 75%),
                linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            border: 2px solid #ddd;
        }

        .canvas-wrapper.interactive {
            cursor: crosshair;
            border-color: #764ba2;
        }

        .canvas-wrapper.interactive:hover {
            box-shadow: 0 6px 20px rgba(118, 75, 162, 0.3);
        }

        .canvas-label {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 600;
            z-index: 1;
            backdrop-filter: blur(10px);
        }

        .canvas-label.clickable {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .color-info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            background: rgba(255,255,255,0.95);
            padding: 10px;
            border-radius: 8px;
            display: none;
            align-items: center;
            gap: 10px;
            font-size: 0.85em;
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .color-info.active {
            display: flex;
        }

        .color-preview {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            border: 2px solid #333;
        }

        .color-text {
            flex: 1;
            font-weight: 500;
            color: #333;
        }

        .removed-colors {
            background: #f9f9f9;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .removed-colors-title {
            font-weight: 600;
            color: #555;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .color-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .color-chip {
            display: flex;
            align-items: center;
            gap: 6px;
            background: white;
            padding: 6px 10px;
            border-radius: 20px;
            border: 2px solid #ddd;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-chip:hover {
            border-color: #ff6b6b;
            transform: scale(1.05);
        }

        .color-chip-preview {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .color-chip-remove {
            color: #ff6b6b;
            font-weight: bold;
            margin-left: 4px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-label {
            cursor: pointer;
            user-select: none;
            font-size: 0.9em;
            color: #555;
        }

        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        button {
            padding: 12px 28px;
            font-size: 1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-danger {
            background: #ff6b6b;
            color: white;
        }

        .btn-danger:hover {
            background: #ff5252;
            transform: translateY(-2px);
        }

        .instructions {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: #856404;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .instructions strong {
            display: block;
            margin-bottom: 5px;
            font-size: 1.1em;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Dynamic Pixel Art Background Remover</h1>
        <p class="subtitle">Click any color to remove it and all connected similar pixels</p>
        
        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">üìÅ</div>
            <p>Click to upload or drag & drop your pixel art</p>
            <input type="file" id="fileInput" accept="image/*">
        </div>

        <div class="workspace" id="workspace">
            <div class="instructions">
                <strong>üñ±Ô∏è How to use:</strong>
                Click any color in the original image to remove it. Adjust the tolerance to include similar colors.
                The flood fill option controls whether only connected pixels or all matching pixels are removed.
            </div>

            <div class="toolbar">
                <div class="toolbar-row">
                    <div class="tool-group">
                        <span class="tool-label">Tolerance:</span>
                        <div class="slider-container">
                            <input type="range" id="tolerance" min="0" max="100" value="5">
                            <span class="slider-value" id="toleranceValue">5%</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="floodFill" checked>
                            <label for="floodFill" class="checkbox-label">Only Connected Pixels</label>
                        </div>
                    </div>
                </div>

                <div class="toolbar-row">
                    <div class="tool-group">
                        <span class="tool-label">Expand:</span>
                        <div class="slider-container">
                            <input type="range" id="expand" min="0" max="5" value="0">
                            <span class="slider-value" id="expandValue">0px</span>
                        </div>
                    </div>
                    
                    <div class="tool-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="smoothEdges">
                            <label for="smoothEdges" class="checkbox-label">Smooth Edges</label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="removed-colors" id="removedColors" style="display: none;">
                <div class="removed-colors-title">üé® Removed Colors (click to restore):</div>
                <div class="color-chips" id="colorChips"></div>
            </div>

            <div class="canvas-area">
                <div class="canvas-wrapper interactive" id="originalWrapper">
                    <span class="canvas-label clickable">Original - Click to Remove Colors</span>
                    <canvas id="originalCanvas"></canvas>
                    <div class="color-info" id="colorInfo">
                        <div class="color-preview" id="colorPreview"></div>
                        <div class="color-text" id="colorText">RGB(255, 255, 255)</div>
                    </div>
                </div>
                <div class="canvas-wrapper">
                    <span class="canvas-label">Result</span>
                    <canvas id="processedCanvas"></canvas>
                </div>
            </div>

            <div class="buttons">
                <button class="btn-secondary" onclick="resetImage()">
                    ‚Ü∫ Reset All Changes
                </button>
                <button class="btn-danger" onclick="undoLast()">
                    ‚Ü∂ Undo Last
                </button>
                <button class="btn-secondary" onclick="uploadNew()">
                    üìÅ New Image
                </button>
                <button class="btn-primary" onclick="downloadImage()">
                    üíæ Download PNG
                </button>
            </div>
        </div>
    </div>

    <script>
        let originalImageData = null;
        let currentImageData = null;
        let removedColors = [];
        let history = [];
        let hoveredColor = null;

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const workspace = document.getElementById('workspace');
        const originalCanvas = document.getElementById('originalCanvas');
        const processedCanvas = document.getElementById('processedCanvas');
        const originalWrapper = document.getElementById('originalWrapper');
        const colorInfo = document.getElementById('colorInfo');
        const colorPreview = document.getElementById('colorPreview');
        const colorText = document.getElementById('colorText');
        const removedColorsSection = document.getElementById('removedColors');
        const colorChips = document.getElementById('colorChips');
        
        const tolerance = document.getElementById('tolerance');
        const toleranceValue = document.getElementById('toleranceValue');
        const expand = document.getElementById('expand');
        const expandValue = document.getElementById('expandValue');
        const floodFill = document.getElementById('floodFill');
        const smoothEdges = document.getElementById('smoothEdges');

        // Upload handlers
        uploadArea.addEventListener('click', () => fileInput.click());
        
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Canvas interaction
        originalCanvas.addEventListener('mousemove', (e) => {
            const rect = originalCanvas.getBoundingClientRect();
            const scaleX = originalCanvas.width / rect.width;
            const scaleY = originalCanvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            
            if (x >= 0 && x < originalCanvas.width && y >= 0 && y < originalCanvas.height) {
                const ctx = originalCanvas.getContext('2d');
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                
                if (pixel[3] > 0) { // Not transparent
                    hoveredColor = [pixel[0], pixel[1], pixel[2], pixel[3]];
                    colorPreview.style.backgroundColor = `rgba(${pixel[0]}, ${pixel[1]}, ${pixel[2]}, ${pixel[3]/255})`;
                    colorText.textContent = `RGB(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
                    colorInfo.classList.add('active');
                } else {
                    colorInfo.classList.remove('active');
                }
            }
        });

        originalCanvas.addEventListener('mouseleave', () => {
            colorInfo.classList.remove('active');
        });

        originalCanvas.addEventListener('click', (e) => {
            if (!currentImageData) return;
            
            const rect = originalCanvas.getBoundingClientRect();
            const scaleX = originalCanvas.width / rect.width;
            const scaleY = originalCanvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            
            if (x >= 0 && x < originalCanvas.width && y >= 0 && y < originalCanvas.height) {
                removeColorAt(x, y);
            }
        });

        // Controls
        tolerance.addEventListener('input', (e) => {
            toleranceValue.textContent = e.target.value + '%';
            if (removedColors.length > 0) {
                applyRemovals();
            }
        });

        expand.addEventListener('input', (e) => {
            expandValue.textContent = e.target.value + 'px';
            if (removedColors.length > 0) {
                applyRemovals();
            }
        });

        floodFill.addEventListener('change', () => {
            if (removedColors.length > 0) {
                applyRemovals();
            }
        });

        smoothEdges.addEventListener('change', () => {
            if (removedColors.length > 0) {
                applyRemovals();
            }
        });

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('Please upload an image file');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    setupCanvas(img);
                    uploadArea.style.display = 'none';
                    workspace.classList.add('active');
                    originalWrapper.classList.add('pulse');
                    setTimeout(() => originalWrapper.classList.remove('pulse'), 2000);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function setupCanvas(img) {
            // Setup original canvas
            originalCanvas.width = img.width;
            originalCanvas.height = img.height;
            const ctx = originalCanvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0);
            originalImageData = ctx.getImageData(0, 0, img.width, img.height);
            currentImageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );

            // Setup processed canvas
            processedCanvas.width = img.width;
            processedCanvas.height = img.height;
            const pCtx = processedCanvas.getContext('2d');
            pCtx.imageSmoothingEnabled = false;
            pCtx.putImageData(currentImageData, 0, 0);
            
            // Reset state
            removedColors = [];
            history = [];
            updateColorChips();
        }

        function removeColorAt(x, y) {
            const ctx = originalCanvas.getContext('2d');
            const pixel = ctx.getImageData(x, y, 1, 1).data;
            
            if (pixel[3] === 0) return; // Already transparent
            
            const color = {
                r: pixel[0],
                g: pixel[1],
                b: pixel[2],
                a: pixel[3],
                x: x,
                y: y
            };
            
            // Save history
            history.push({
                imageData: new ImageData(
                    new Uint8ClampedArray(currentImageData.data),
                    currentImageData.width,
                    currentImageData.height
                ),
                removedColors: [...removedColors]
            });
            
            // Add to removed colors if not already there
            const exists = removedColors.some(c => 
                c.r === color.r && c.g === color.g && 
                c.b === color.b && c.a === color.a
            );
            
            if (!exists || floodFill.checked) {
                removedColors.push(color);
            }
            
            applyRemovals();
            updateColorChips();
        }

        function applyRemovals() {
            // Start fresh from original
            currentImageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );
            
            const width = currentImageData.width;
            const height = currentImageData.height;
            const data = currentImageData.data;
            const mask = new Uint8Array(width * height);
            const toleranceVal = parseInt(tolerance.value);
            const expandVal = parseInt(expand.value);
            
            // Process each removed color
            removedColors.forEach(color => {
                if (floodFill.checked && color.x !== undefined && color.y !== undefined) {
                    // Flood fill from click point
                    floodFillFromPoint(data, mask, width, height, color, toleranceVal);
                } else {
                    // Remove all matching pixels
                    removeAllMatchingPixels(data, mask, width, height, color, toleranceVal);
                }
            });
            
            // Expand removal area if needed
            if (expandVal > 0) {
                expandMask(mask, width, height, expandVal);
            }
            
            // Smooth edges if enabled
            if (smoothEdges.checked) {
                smoothMaskEdges(mask, width, height);
            }
            
            // Apply mask
            for (let i = 0; i < mask.length; i++) {
                if (mask[i] === 1) {
                    data[i * 4 + 3] = 0; // Set alpha to 0
                }
            }
            
            // Update canvases
            const ctx = originalCanvas.getContext('2d');
            ctx.putImageData(currentImageData, 0, 0);
            
            const pCtx = processedCanvas.getContext('2d');
            pCtx.clearRect(0, 0, width, height);
            pCtx.putImageData(currentImageData, 0, 0);
        }

        function floodFillFromPoint(data, mask, width, height, color, tolerance) {
            const queue = [{x: color.x, y: color.y}];
            const visited = new Set();
            
            while (queue.length > 0) {
                const {x, y} = queue.shift();
                const key = `${x},${y}`;
                
                if (visited.has(key) || x < 0 || x >= width || y < 0 || y >= height) {
                    continue;
                }
                
                visited.add(key);
                const index = y * width + x;
                
                if (mask[index] === 1) continue;
                
                const pixelIndex = index * 4;
                if (data[pixelIndex + 3] === 0) continue; // Skip transparent
                
                if (isColorSimilar(data, pixelIndex, color, tolerance)) {
                    mask[index] = 1;
                    
                    // Add neighbors
                    queue.push({x: x + 1, y});
                    queue.push({x: x - 1, y});
                    queue.push({x, y: y + 1});
                    queue.push({x, y: y - 1});
                    
                    // Add diagonal neighbors for better connectivity
                    queue.push({x: x + 1, y: y + 1});
                    queue.push({x: x - 1, y: y - 1});
                    queue.push({x: x + 1, y: y - 1});
                    queue.push({x: x - 1, y: y + 1});
                }
            }
        }

        function removeAllMatchingPixels(data, mask, width, height, color, tolerance) {
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = y * width + x;
                    if (mask[index] === 1) continue;
                    
                    const pixelIndex = index * 4;
                    if (data[pixelIndex + 3] === 0) continue; // Skip transparent
                    
                    if (isColorSimilar(data, pixelIndex, color, tolerance)) {
                        mask[index] = 1;
                    }
                }
            }
        }

        function isColorSimilar(data, index, targetColor, tolerance) {
            const dr = Math.abs(data[index] - targetColor.r);
            const dg = Math.abs(data[index + 1] - targetColor.g);
            const db = Math.abs(data[index + 2] - targetColor.b);
            
            // Use Euclidean distance in RGB space
            const distance = Math.sqrt(dr * dr + dg * dg + db * db);
            const maxDistance = Math.sqrt(3 * 255 * 255);
            
            return (distance / maxDistance * 100) <= tolerance;
        }

        function expandMask(mask, width, height, pixels) {
            for (let i = 0; i < pixels; i++) {
                const tempMask = new Uint8Array(mask);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = y * width + x;
                        
                        if (tempMask[index] === 1) {
                            // Mark neighbors
                            if (x > 0) mask[(y * width) + (x - 1)] = 1;
                            if (x < width - 1) mask[(y * width) + (x + 1)] = 1;
                            if (y > 0) mask[((y - 1) * width) + x] = 1;
                            if (y < height - 1) mask[((y + 1) * width) + x] = 1;
                        }
                    }
                }
            }
        }

        function smoothMaskEdges(mask, width, height) {
            const tempMask = new Uint8Array(mask);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const index = y * width + x;
                    
                    // Count neighbors
                    let neighbors = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            if (tempMask[(y + dy) * width + (x + dx)] === 1) {
                                neighbors++;
                            }
                        }
                    }
                    
                    // Smooth based on neighbor count
                    if (neighbors >= 6) {
                        mask[index] = 1;
                    } else if (neighbors <= 2) {
                        mask[index] = 0;
                    }
                }
            }
        }

        function updateColorChips() {
            if (removedColors.length === 0) {
                removedColorsSection.style.display = 'none';
                return;
            }
            
            removedColorsSection.style.display = 'block';
            colorChips.innerHTML = '';
            
            // Group similar colors
            const uniqueColors = [];
            removedColors.forEach(color => {
                const exists = uniqueColors.some(c => 
                    c.r === color.r && c.g === color.g && 
                    c.b === color.b && c.a === color.a
                );
                if (!exists) {
                    uniqueColors.push(color);
                }
            });
            
            uniqueColors.forEach((color, index) => {
                const chip = document.createElement('div');
                chip.className = 'color-chip';
                chip.innerHTML = `
                    <div class="color-chip-preview" style="background: rgba(${color.r}, ${color.g}, ${color.b}, ${color.a/255})"></div>
                    <span>RGB(${color.r}, ${color.g}, ${color.b})</span>
                    <span class="color-chip-remove">√ó</span>
                `;
                chip.onclick = () => restoreColor(color);
                colorChips.appendChild(chip);
            });
        }

        function restoreColor(color) {
            // Save history
            history.push({
                imageData: new ImageData(
                    new Uint8ClampedArray(currentImageData.data),
                    currentImageData.width,
                    currentImageData.height
                ),
                removedColors: [...removedColors]
            });
            
            // Remove all instances of this color
            removedColors = removedColors.filter(c => 
                !(c.r === color.r && c.g === color.g && 
                  c.b === color.b && c.a === color.a)
            );
            
            applyRemovals();
            updateColorChips();
        }

        function undoLast() {
            if (history.length === 0) return;
            
            const state = history.pop();
            currentImageData = state.imageData;
            removedColors = state.removedColors;
            
            const ctx = originalCanvas.getContext('2d');
            ctx.putImageData(currentImageData, 0, 0);
            
            const pCtx = processedCanvas.getContext('2d');
            pCtx.clearRect(0, 0, currentImageData.width, currentImageData.height);
            pCtx.putImageData(currentImageData, 0, 0);
            
            updateColorChips();
        }

        function resetImage() {
            if (!originalImageData) return;
            
            currentImageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );
            
            const ctx = originalCanvas.getContext('2d');
            ctx.putImageData(currentImageData, 0, 0);
            
            const pCtx = processedCanvas.getContext('2d');
            pCtx.clearRect(0, 0, currentImageData.width, currentImageData.height);
            pCtx.putImageData(currentImageData, 0, 0);
            
            removedColors = [];
            history = [];
            updateColorChips();
        }

        function uploadNew() {
            uploadArea.style.display = 'block';
            workspace.classList.remove('active');
            fileInput.value = '';
            originalImageData = null;
            currentImageData = null;
            removedColors = [];
            history = [];
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'pixel-art-no-bg.png';
            link.href = processedCanvas.toDataURL();
            link.click();
        }
    </script>
</body>
</html>